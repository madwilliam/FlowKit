function [scanData,arb_struct] = CM_loadpmtdatatostruct_to_scan_data( filename )
%This function load pmtdata file and save it as data struct
%filename  a string of file name, not including extensions

%arb_struct contains the following fields:
%pmtdata            matrix of pmt data Nptpercycle*Nchannels*Ncycles
%scannerPosData     scannerposition feedback signal, if any
%linescanchannels   vector of channel id saved in linescandata
%header             header generated by readLineScanDataFile, contain scanning
%                   parameter info
%roiGroup           roiGroup object as per scanimage format
%imagechannel       identity of channels saved in the two images.

%scanData contains these fields
%pathObjNum to use for GUI first ROI is 1, second is 2....in the order of
%the path



%This function depends on scanimage installation.

%load pmt data
[header, pmtData, scannerPosData, roiGroup] = scanimage.util.readLineScanDataFiles(filename);
arb_struct.header=header;
%arb_struct.pmtdata=pmtData;
arb_struct.roiGroup=roiGroup;
arb_struct.scannerPosData=scannerPosData; %not sure if read linescan return only one cycle or muiltiple.
%if returns too much, maybe average to one cycle.
arb_struct.linescanchannel=header.SI.hChannels.channelSave;

%load scanfield image
[imgheader,XStk,~]=scanimage.util.opentif;  %manually select tif image of the scanfield.
imagechannel=imgheader.SI.hChannels.channelSave;
scanData.im=zeros(size(XStk,1),size(XStk,2),4);

for jj=1:numel(imagechannel)
    ch_num=imagechannel(jj);
    quickstk=squeeze((XStk(:,:,jj,:)));size(quickstk)
    scanData.im(:,:,ch_num)=mean(quickstk,3); %Average image for j's channel
end

%process roi group to get pointtime data and linetime data
nrois=length(roiGroup.activeRois);
samplerate=header.sampleRate;
%% CM PART
points_per_line=header.samplesPerFrame;
time_per_line=header.samplesPerFrame/header.sampleRate;

pathObjNum=zeros(points_per_line,1);
nptpassed=0;
nline=0;npause=0;npoint=0;nwaypoint=0;nsinesquare=0;nlogspiral=0;nothershape=0;
for ii=1:nrois
    RoiStr=roiGroup.activeRois(ii).scanfields.shortDescription;
    scanData.scanCoords(1,ii).scanShape=strrep(RoiStr, 'Stim: ', '');
    sizeXY=roiGroup.activeRois(1,1).scanfields.sizeXY;
    diagon=sqrt(sizeXY(1,1).^2+sizeXY(1,2).^2);
    scanData.scanVelocity(1,ii)=diagon/roiGroup.activeRois(ii).scanfields.duration;% will only apply to lines...
    switch roiGroup.activeRois(ii).scanfields.shortDescription
        case 'Stim: pause'
            npause=npause+1;
            nroipoints=round(roiGroup.activeRois(ii).scanfields.duration*samplerate);% nb of points for this pause
            pathObjNum ([1:nroipoints]+nptpassed)=0;
            nptpassed=nptpassed+nroipoints;
            scanData.scanCoords(1,ii).name=[scanData.scanCoords(1,ii).scanShape '_' num2str(npause)];
            
        case 'Stim: line'
            nline=nline+1;
            nroipoints=round(roiGroup.activeRois(ii).scanfields.duration*samplerate);% nb of points for this line
            pathObjNum ([1:nroipoints]+nptpassed)=ii;
            nptpassed=nptpassed+nroipoints;
            scanData.scanCoords(1,ii).name=[scanData.scanCoords(1,ii).scanShape '_' num2str(nline)];
            
        case 'Stim: point'
            npoint=npoint+1;
            nroipoints=round(roiGroup.activeRois(ii).scanfields.duration*samplerate);% nb of points for this line
            pathObjNum ([1:nroipoints]+nptpassed)=ii;
            nptpassed=nptpassed+nroipoints;
            scanData.scanCoords(1,ii).name=[scanData.scanCoords(1,ii).scanShape '_' num2str(npoint)];
            
        case 'Stim: waypoint'
            nwaypoints=nwaypoints+1;
            nroipoints=round(roiGroup.activeRois(ii).scanfields.duration*samplerate);% nb of points for this line
            pathObjNum ([1:nroipoints]+nptpassed)=ii;
            nptpassed=nptpassed+nroipoints;
            scanData.scanCoords(1,ii).name=[scanData.scanCoords(1,ii).scanShape '_' num2str(nwaypoint)];
            
        case 'Stim: logspiral'
            nlogspiral=nlogspiral+1;
            nroipoints=round(roiGroup.activeRois(ii).scanfields.duration*samplerate);% nb of points for this line
            pathObjNum ([1:nroipoints]+nptpassed)=ii;
            nptpassed=nptpassed+nroipoints;
            scanData.scanCoords(1,ii).name=[scanData.scanCoords(1,ii).scanShape '_' num2str(nlogspiral)];
            
        case 'Stim: sinesquare'
            nsinesquare=nsinesquare+1;
            nroipoints=round(roiGroup.activeRois(ii).scanfields.duration*samplerate);% nb of points for this line
            pathObjNum ([1:nroipoints]+nptpassed)=ii;
            nptpassed=nptpassed+nroipoints;
            scanData.scanCoords(1,ii).name=[scanData.scanCoords(1,ii).scanShape '_' num2str(nsinesquare)];
            
        otherwise %for other type of ROI, add time to nptpassed
            nothershape=nothershape+1
            nroipoints=round(roiGroup.activeRois(ii).scanfields.duration*samplerate);
            pathObjNum ([1:nroipoints]+nptpassed)=ii;
            nptpassed=nptpassed+nroipoints;
            scanData.scanCoords(1,ii).name=[scanData.scanCoords(1,ii).scanShape '_' num2str(nothershape)];
            
    end
    %check if nptpassed corresponds to the size of the pmtdata
end

scanData.dt=double(1/samplerate);
scanData.fs=samplerate;
% is for each
% scanData.path=;
% % scanData.returnedPath=;  % not needed anymore
% % scanData.maxAcc=; % not needed anymore
% scanData.im=;
scanData.axisLimRow=[imgheader.SI.hRoiManager.imagingFovDeg(1,1),imgheader.SI.hRoiManager.imagingFovDeg(3,1)];
scanData.axisLimCol=[imgheader.SI.hRoiManager.imagingFovDeg(1,2),imgheader.SI.hRoiManager.imagingFovDeg(3,2)];
%scanData.scanCoords=;
scanData.pathObjNum=pathObjNum;
% scanData.pathObjSubNum=pathObjSubNum;
arb_struct.scanData=scanData;
end

